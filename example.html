<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Babylon TetGen Integration</title>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

    <!-- External Libraries -->
    <link rel="stylesheet" href="https://use.typekit.net/cta4xsb.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" />  

    <!-- DatGUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery.js"></script>

    <!-- Babylon.js Dependencies -->
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/recast.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>

    <!-- Babylon.js Core -->
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <script src="https://preview.babylonjs.com/nodeEditor/babylon.nodeEditor.js"></script>
    <script src="https://preview.babylonjs.com/guiEditor/babylon.guiEditor.js"></script>
</head>

<body>
    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <!-- Load the Emscripten Module FIRST -->
    <script src="babylon2tet.js"></script>

    <!-- Your Main JavaScript Code -->
    <script>
        async function init() {
            var canvas = document.getElementById("renderCanvas"); // Get the canvas element
            var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

            /******* Add the create scene function ******/

            var createScene = function () {
                var scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(.5, .5, .5);

                // Camera
                var camera = new BABYLON.ArcRotateCamera("camera1", Math.PI / 2, Math.PI / 4, 30, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvas, true);

                // Lighting
                var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
                light.intensity = 0.7;

                var pl = new BABYLON.PointLight("pl", BABYLON.Vector3.Zero(), scene);
                pl.diffuse = new BABYLON.Color3(1, 1, 1);
                pl.specular = new BABYLON.Color3(1, 1, 1);
                pl.intensity = 0.8;

                // Add and manipulate meshes in the scene
                var sphere = BABYLON.Mesh.CreateTorusKnot("knot0", 20, 5, 128, 128, 2, 3, scene);

                var alphamat = new BABYLON.StandardMaterial('alphamat', scene);
                alphamat.diffuseColor = BABYLON.Color3.Blue();
                alphamat.emissiveColor = new BABYLON.Color3(1.0, .1, .1);
                alphamat.alpha = 0.1;
                sphere.material = alphamat;
                sphere.enableEdgesRendering();
                sphere.edgesWidth = 5.0;
                sphere.edgesColor = new BABYLON.Color4(1, 0, 0, 1);

                // Initialize the Emscripten Module
                try {
                    const Module = await createTetGenModule();
                    console.log("Emscripten Module Loaded");

                    // Function to process the mesh
                    async function processmesh(mesh) {
                        // Extract positions and indices from the mesh
                        var positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
                        var indices = mesh.getIndices();

                        // Convert positions and indices to TypedArrays
                        var bpositions = new Float64Array(positions);
                        var bindices = new Uint32Array(indices);

                        var bnumpositions = mesh.getTotalVertices();
                        var bnumindices = indices.length;

                        // Allocate memory in Emscripten heap for input data
                        var bpositionsPtr = Module._malloc(bpositions.length * Float64Array.BYTES_PER_ELEMENT);
                        Module.HEAPF64.set(bpositions, bpositionsPtr / Float64Array.BYTES_PER_ELEMENT);

                        var bindicesPtr = Module._malloc(bindices.length * Uint32Array.BYTES_PER_ELEMENT);
                        Module.HEAPU32.set(bindices, bindicesPtr / Uint32Array.BYTES_PER_ELEMENT);

                        // Allocate memory for output data
                        var maxVertices = bnumpositions * 3; // Adjust as needed
                        var verticesOut = new Float64Array(maxVertices * 3);
                        var verticesOutPtr = Module._malloc(verticesOut.length * Float64Array.BYTES_PER_ELEMENT);

                        var maxTetrahedra = bnumpositions * 2; // Adjust as needed
                        var tetrahedraOut = new Uint32Array(maxTetrahedra * 4);
                        var tetrahedraOutPtr = Module._malloc(tetrahedraOut.length * Uint32Array.BYTES_PER_ELEMENT);

                        // Allocate memory for output counts
                        var numVerticesOutPtr = Module._malloc(4); // uint32_t
                        var numTetrahedraOutPtr = Module._malloc(8); // uint64_t

                        // Call the babylon2tetgen function
                        Module.ccall(
                            'babylon2tetgen',
                            'number', // return type
                            [
                                'number', // bnumpositions
                                'number', // bpositionsPtr
                                'number', // bnumindices
                                'number', // bindicesPtr
                                'number', // numVerticesOutPtr
                                'number', // verticesOutPtr
                                'number', // numTetrahedraOutPtr
                                'number'  // tetrahedraOutPtr
                            ],
                            [
                                bnumpositions,
                                bpositionsPtr,
                                bnumindices,
                                bindicesPtr,
                                numVerticesOutPtr,
                                verticesOutPtr,
                                numTetrahedraOutPtr,
                                tetrahedraOutPtr
                            ]
                        );

                        // Retrieve output counts
                        var numVerticesOut = Module.getValue(numVerticesOutPtr, 'i32');
                        var numTetrahedraOutLow = Module.getValue(numTetrahedraOutPtr, 'i32'); // Lower 32 bits
                        var numTetrahedraOutHigh = Module.getValue(numTetrahedraOutPtr + 4, 'i32'); // Higher 32 bits
                        var numTetrahedraOut = numTetrahedraOutHigh * 4294967296 + numTetrahedraOutLow; // Combine into uint64

                        console.log("Number of output vertices:", numVerticesOut);
                        console.log("Number of output tetrahedra:", numTetrahedraOut);

                        // Retrieve output data
                        verticesOut.set(Module.HEAPF64.subarray(verticesOutPtr / Float64Array.BYTES_PER_ELEMENT, verticesOutPtr / Float64Array.BYTES_PER_ELEMENT + numVerticesOut * 3));
                        tetrahedraOut.set(Module.HEAPU32.subarray(tetrahedraOutPtr / Uint32Array.BYTES_PER_ELEMENT, tetrahedraOutPtr / Uint32Array.BYTES_PER_ELEMENT + numTetrahedraOut * 4));

                        // Free allocated memory
                        Module._free(bpositionsPtr);
                        Module._free(bindicesPtr);
                        Module._free(verticesOutPtr);
                        Module._free(tetrahedraOutPtr);
                        Module._free(numVerticesOutPtr);
                        Module._free(numTetrahedraOutPtr);

                        // Return the result
                        return {
                            vertices: verticesOut.slice(0, numVerticesOut * 3),
                            tetrahedra: tetrahedraOut.slice(0, numTetrahedraOut * 4)
                        };
                    }

                    // Function to visualize the tetrahedral mesh
                    function visualizeTetrahedralMesh(vertices, tetrahedra, scene) {
                        // Create a new mesh for the tetrahedral elements
                        var tetraMesh = new BABYLON.Mesh("tetraMesh", scene);
                        var vertexData = new BABYLON.VertexData();

                        vertexData.positions = vertices;
                        // Optionally, compute normals or other vertex data

                        // Build tetrahedral faces (each tetrahedron has 4 triangular faces)
                        var indices = [];

                        for (var i = 0; i < tetrahedra.length; i += 4) {
                            var a = tetrahedra[i];
                            var b = tetrahedra[i + 1];
                            var c = tetrahedra[i + 2];
                            var d = tetrahedra[i + 3];

                            // Add faces of the tetrahedron
                            // Face 1: a, b, c
                            indices.push(a, b, c);
                            // Face 2: a, b, d
                            indices.push(a, b, d);
                            // Face 3: a, c, d
                            indices.push(a, c, d);
                            // Face 4: b, c, d
                            indices.push(b, c, d);
                        }

                        vertexData.indices = indices;

                        // Apply vertex data to the tetrahedral mesh
                        vertexData.applyToMesh(tetraMesh, true);

                        // Set material to visualize
                        var tetraMaterial = new BABYLON.StandardMaterial("tetraMaterial", scene);
                        tetraMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0);
                        tetraMaterial.alpha = 0.3;
                        tetraMesh.material = tetraMaterial;

                        // Enable back-face culling if needed
                        tetraMesh.material.backFaceCulling = false;

                        // Optional: Add wireframe
                        tetraMesh.enableEdgesRendering();
                        tetraMesh.edgesWidth = 1.0;
                        tetraMesh.edgesColor = new BABYLON.Color4(0, 0, 0, 1);

                        console.log("Tetrahedral mesh visualization added.");
                    }

                    // Process the sphere mesh
                    processmesh(sphere).then(function(value) {
                        console.log("Tetrahedral Mesh Generated:", value);
                        // Visualize the tetrahedral mesh
                        visualizeTetrahedralMesh(value.vertices, value.tetrahedra, scene);
                    }).catch(function(error) {
                        console.error("Failed to generate tetrahedral mesh:", error);
                    });
                };

                var scene = createScene(); // Call the createScene function

                // Register a render loop to repeatedly render the scene
                engine.runRenderLoop(function () {
                    scene.render();
                });

                // Watch for browser/canvas resize events
                window.addEventListener("resize", function () {
                    engine.resize();
                });
            }

            // Initialize the scene
            init();
        </script>
</body>

</html>
